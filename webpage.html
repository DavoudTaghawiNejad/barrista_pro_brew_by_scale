<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/chartist.js/latest/chartist.min.css">
    <script src="https://cdn.jsdelivr.net/chartist.js/latest/chartist.min.js"></script>
    <title>Barrista Uber - by Davoud Taghawi-Nejad</title>
    <link href="https://unpkg.com/material-components-web@14.0.0/dist/material-components-web.min.css" rel="stylesheet">
    <script src="https://unpkg.com/material-components-web@14.0.0/dist/material-components-web.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; }
        .container { max-width: 800px; margin: auto; padding: 20px; }
        .controls { margin: 20px 0; }
        input { width: 100px; text-align: center; }
        canvas { max-width: 100%; }
        #chart-container {
            height: 600px;  /* Set to twice the assumed original height for better visibility */
        }
        /* Hide number input spin buttons (Chrome, Safari, Edge) */
        input[type=number]::-webkit-inner-spin-button,
        input[type=number]::-webkit-outer-spin-button {
        -webkit-appearance: none;
        margin: 0;
        }
        /* Hide number input spin buttons (Firefox) */
        input[type=number] {
        -moz-appearance: textfield;
        }
        #legend {
            font-size: 14px;
            border-top: 1px solid #ccc;
            padding-top: 10px;
            margin-top: 10px;
        }
    </style>
    <style>
        .mdc-floating-label {
            text-align: left;  /* Align label to the left */
            position: absolute;  /* Ensure it's positioned absolutely if needed */
            left: 0;  /* Align to the left edge */
        }
        .mdc-notched-outline {
            display: flex;  /* Use flex to align contents */
            align-items: center;  /* Center vertically if needed */
        }
    </style>
</head>
<body>
    <div class="mdc-snackbar">
        <div class="mdc-snackbar__surface">
            <div class="mdc-snackbar__label" role="status" aria-live="polite"></div>
            <div class="mdc-snackbar__actions">
                <button type="button" class="mdc-button mdc-snackbar__action">
                    <div class="mdc-button__ripple"></div>
                    <span class="mdc-button__label">Dismiss</span>
                </button>
            </div>
        </div>
    </div>

    <div class="container">
        <h1>Barrista Uber - by Davoud Taghawi-Nejad</h1>
        <div id="chart-container"></div>
<div class="controls">
    <h3>Select or Create Coffee</h3>
    <label for="coffeeSelect">Coffee Profile:</label>
    <select id="coffeeSelect" class="mdc-select">
        <option value="">Select or Add Coffee</option>
        <!-- Options will be populated dynamically -->
    </select>
    <!-- Removed Load Coffees button -->
    <button class="mdc-button mdc-button--outlined" onclick="addNewCoffee()">Add New Coffee</button>
    <br><br>
    <h3>Adjust Values</h3>
    <label>Dose (grams):</label>
    <button class="mdc-button mdc-button--raised" id="decreaseDose">-</button>
    <label class="mdc-text-field mdc-text-field--outlined" style="width: 100px;">
        <input type="number" id="dose" class="mdc-text-field__input" step="0.1" min="0" style="width: 100px;">
        <span class="mdc-notched-outline">
          <span class="mdc-notched-outline__leading"></span>
          <span class="mdc-notched-outline__notch">
            <span class="mdc-floating-label"></span>
          </span>
          <span class="mdc-notched-outline__trailing"></span>
        </span>
      </label>
    <button class="mdc-button mdc-button--raised" id="increaseDose">+</button>
    <br><br>
    <label>Grind Size:</label>
    <button class="mdc-button mdc-button--raised" id="decreaseGrind">-</button>
    <label class="mdc-text-field mdc-text-field--outlined" style="width: 100px;">
        <input type="number" id="grind_size" class="mdc-text-field__input" step="1" min="0" style="width: 100px;">
        <span class="mdc-notched-outline">
          <span class="mdc-notched-outline__leading"></span>
          <span class="mdc-notched-outline__notch">
            <span class="mdc-floating-label"></span>
          </span>
          <span class="mdc-notched-outline__trailing"></span>
        </span>
      </label>
    <button class="mdc-button mdc-button--raised" id="increaseGrind">+</button>
    <br><br>
    <label>Extraction (grams):</label>
    <button class="mdc-button mdc-button--raised" id="decrease">-</button>
    <label class="mdc-text-field mdc-text-field--outlined" style="width: 100px;">
        <input type="number" id="extraction" class="mdc-text-field__input" min="0" min="200" style="width: 100px;" step="1">
        <span class="mdc-notched-outline">
          <span class="mdc-notched-outline__leading"></span>
          <span class="mdc-notched-outline__notch">
            <span class="mdc-floating-label"></span>
          </span>
          <span class="mdc-notched-outline__trailing"></span>
        </span>
      </label>
    <button class="mdc-button mdc-button--raised" id="increase">+</button>
    <br><br>
    <button class="mdc-button mdc-button--outlined" onclick="updateValues()">Remember Coffee</button>
    <button class="mdc-button mdc-button--raised" onclick="makeCoffee()">Make Coffee</button>
</div>
    </div>

<script>
let isMakingCoffee = false;
let pollInterval;
let snackbar;
const colors = ['blue', 'red', 'green', 'purple', 'magenta', 'cyan', 'orange', 'yellow', 'lime', 'navy', 'pink', 'brown'];
let coffee_number = 0;

const chart = new Chartist.Line('#chart-container', {
        labels: [],
        series: []
    }, {
        axisX: {
            type: Chartist.FixedScaleAxis,
            ticks: [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60],  // Ticks every 5 seconds
            high: 60,
            low: 0,
            labelInterpolationFnc: function(value) { return value + ' s'; },
            showPoint: false  // Explicitly ensure no point markers
        },
        axisY: {
            type: Chartist.FixedScaleAxis,
            ticks: [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60],  // Ticks every 5 grams
            high: 60,
            low: 0,
            labelInterpolationFnc: function(value) { return value + ' g'; },
            showPoint: false  // Explicitly ensure no point markers
        },
        line: {
            width: 1.12  // Further reduced by 30% from 1.6
        }
    });

    // Add simple axis labels manually with improved styling
    const chartContainer = document.getElementById('chart-container');
    const xLabel = document.createElement('div');
    xLabel.style.position = 'absolute';
    xLabel.style.bottom = '5px';  // Adjusted for better visibility
    xLabel.style.left = '50%';
    xLabel.style.transform = 'translateX(-50%)';
    xLabel.style.fontSize = '14px';
    xLabel.style.color = 'black';  // Ensure visibility
    xLabel.textContent = 'Seconds';
    chartContainer.appendChild(xLabel);

    const yLabel = document.createElement('div');
    yLabel.style.position = 'absolute';
    yLabel.style.top = '50%';
    yLabel.style.left = '5px';  // Adjusted for better visibility
    yLabel.style.transform = 'rotate(-90deg) translateX(-50%) translateY(-50%)';
    yLabel.style.fontSize = '14px';
    yLabel.style.color = 'black';  // Ensure visibility
    yLabel.textContent = 'Extraction (grams)';
    chartContainer.appendChild(yLabel);

    // Additional CSS to hide any potential point markers
    const style = document.createElement('style');
    style.innerHTML = `
        .ct-point { display: none !important; }  // Force hide points if they persist
    `;
    document.head.appendChild(style);

// Add simple legend after chart initialization
const legendContainer = document.createElement('div');
legendContainer.id = 'legend';
legendContainer.style.position = 'relative';  // Ensure positioning
legendContainer.style.textAlign = 'center';
legendContainer.style.marginTop = '20px';  // Position under the graph
document.getElementById('chart-container').insertAdjacentElement('afterend', legendContainer);  // Adjusted insertion to place after chart container

// Function to update legend (call after chart update)
function updateLegend() {
    const series = chart.data.series;
    const legend = document.getElementById('legend');
    legend.innerHTML = '';  // Clear existing
series.forEach((s, index) => {
    if (s.meta) {  // Skip series without meta
        const legendItem = document.createElement('span');
        legendItem.style.display = 'inline-block';
        legendItem.style.margin = '0 10px';
        legendItem.innerHTML = `<span style="color: ${colors[index % colors.length]};">&#9632;</span> ${s.meta}`;
        legend.appendChild(legendItem);
    }
});
}

// Call updateLegend after updating chart data
// This assumes the original code's polling function; hook into it if possible

async function makeCoffee() {
    if (isMakingCoffee) {
        snackbar.labelText = 'Coffee is already being made.';
        snackbar.open();
         return;
    }

    snackbar.labelText = 'Making Coffee.';
    snackbar.open();

    isMakingCoffee = true;
    coffee_number += 1;
    const selectedCoffee = document.getElementById('coffeeSelect').value;
    const extraction = document.getElementById('extraction').value;

    try {
        const response = await fetch('/make_coffee', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name: selectedCoffee, extraction })
        });

        if (!response.ok) {
            snackbar.labelText = 'Coffee making failed.';
            snackbar.open();
            isMakingCoffee = false;
            return;
        }
    } catch (error) {
        isMakingCoffee = false;
        snackbar.labelText = 'Error starting coffee: ' + error.message;
        snackbar.open();
    }

    // Start polling after coffee request succeeded
    pollInterval = setInterval(async () => {
        try {
            const chartDataResponse = await fetch('/get_chart_data');
            if (chartDataResponse.ok) {
                const responseData = await chartDataResponse.json();

                if (responseData.is_makeing_coffee === false) {
                    clearInterval(pollInterval);
                    isMakingCoffee = false;
                    snackbar.labelText = 'Coffee made successfully.';
                    snackbar.open();
                }

                if (responseData.data && responseData.data.length > 0) {
if (chart.data.series.length < coffee_number + 1) {
    chart.data.series.push({ meta: selectedCoffee + ' ' + coffee_number, value: [] });
}

                    if (!chart.data.series[coffee_number].value) {
                        chart.data.series[coffee_number].value = [];
                    }

                    chart.data.series[coffee_number].value = [
                        ...chart.data.series[coffee_number].value,
                        ...responseData.data
                    ];
                chart.update();
                updateLegend();  // Call to update legend after chart data changes

                const maxX = Math.max(...responseData.data.map(pair => pair[0] || 0), 60);
                const maxY = Math.max(...responseData.data.map(pair => pair[1] || 0), 60);

                if (maxX > 60 || maxY > 60) {
                    chart.options.axisX.high = maxX;
                    chart.options.axisY.high = maxY;
                    chart.update();
                    updateLegend();  // Call again if chart options change
                }
                }
            }
        } catch (error) {
            clearInterval(pollInterval);
            isMakingCoffee = false;
            snackbar.labelText = 'Polling error: ' + error.message;
            snackbar.open();
        }
    }, 400);

}


async function updateValues() {
    const selectedCoffee = document.getElementById('coffeeSelect').value;
    const dose = document.getElementById('dose').value;
    const grind_size = document.getElementById('grind_size').value;
    const extraction = document.getElementById('extraction').value;

    if (selectedCoffee) {
        const data = { name: selectedCoffee };
        if (dose) data.dose = dose;
        if (grind_size) data.grind_size = grind_size;
        if (extraction) data.extraction = extraction;

        const response = await fetch('/update_coffee', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });
        if (response.ok) {
            snackbar.labelText = 'Coffee updated!';
            snackbar.open();
            // Removed loadData call
        } else {
            snackbar.labelText = 'Update failed. Please try again.';
            snackbar.open();
        }
    } else {
        snackbar.labelText = 'Please select a coffee first.';
        snackbar.open();
    }
}

async function loadCoffees() {
    const response = await fetch('/get_coffee_names');
    if (response.ok) {
        const data = await response.json();
        const select = document.getElementById('coffeeSelect');
        select.innerHTML = '<option value="">Select Coffee</option>';
        data.names.forEach(name => {
            const option = document.createElement('option');
            option.value = name;
            option.text = name;
            select.appendChild(option);
        });
    } else {
        snackbar.labelText = 'Failed to load coffees.';
        snackbar.open();
    }
}

async function addNewCoffee() {
    const name = prompt('Enter name for new coffee:');
    const dose = document.getElementById('dose').value;  // Add this line
    const grind_size = document.getElementById('grind_size').value;  // Add this line
    const extraction = document.getElementById('extraction').value;  // Add this line
    if (name && dose !== '' && grind_size !== '' && extraction !== '') {  // Check for all values
        const response = await fetch('/add_coffee', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name: name, dose: dose, grind_size: grind_size, extraction: extraction })
        });
        if (response.ok) {
            snackbar.labelText = 'New coffee added!';
            snackbar.open();
            loadCoffees();  // Reload coffees
        } else {
            snackbar.labelText = 'Failed to add coffee.';
            snackbar.open();
        }
    } else {
        snackbar.labelText = 'Please provide name, dose, grind_size, and extraction.';
        snackbar.open();
    }
}

window.onload = function () {
    loadCoffees().then(() => {
        async function fetchLastBrewed() {
            try {
                const response = await fetch('/get_last_brewed');
                if (response.ok) {
                    const data = await response.json();
                    const lastBrewed = data.last_brewed;
                    if (lastBrewed) {
                        document.getElementById('coffeeSelect').value = lastBrewed;
                        document.getElementById('coffeeSelect').dispatchEvent(new Event('change'));  // Trigger change to populate fields
                    }
                }
            } catch (error) {
                console.error("Error fetching last brewed coffee:", error);
            }
        }
        fetchLastBrewed();  // Call the function after loadCoffees, thanks to .then
    });
document.getElementById('coffeeSelect').addEventListener('change', async function() {
    const selectedCoffeeName = this.value;
    if (selectedCoffeeName) {
        const response = await fetch('/get_coffee?name=' + selectedCoffeeName);
        if (response.ok) {
            const data = await response.json();
            if (data.coffee) {  // Assuming the response is { 'coffee': { ... } }
                document.getElementById('dose').value = data.coffee.dose || '';
                document.getElementById('grind_size').value = data.coffee.grind_size || '';
                document.getElementById('extraction').value = data.coffee.extraction || '';
            } else {
                snackbar.labelText = 'Coffee details not found.';
                snackbar.open();
            }
        } else {
            snackbar.labelText = 'Failed to load coffee details.';
            snackbar.open();
        }
    } else {
        document.getElementById('dose').value = '';
        document.getElementById('grind_size').value = '';
        document.getElementById('extraction').value = '';
    }
});
    loadCoffees().then(() => {
        if (document.getElementById('coffeeSelect').options.length > 1) {
            document.getElementById('coffeeSelect').value = document.getElementById('coffeeSelect').options[document.getElementById('coffeeSelect').options.length - 1].value;
            document.getElementById('coffeeSelect').dispatchEvent(new Event('change'));
        }
    });
    // Initialize MDC buttons
    const buttons = document.querySelectorAll('.mdc-button');
    buttons.forEach(button => mdc.ripple.MDCRipple.attachTo(button));
    mdc.textField.MDCTextField.attachTo(document.querySelector('.mdc-text-field'));

    // Initialize snackbar once
    snackbar = mdc.snackbar.MDCSnackbar.attachTo(document.querySelector('.mdc-snackbar'));
};

        document.getElementById('decrease').addEventListener('click', function () {
            const input = document.getElementById('extraction');
            let value = parseInt(input.value) || 0;
            if (value > 0) input.value = value - 1;
        });

        document.getElementById('increase').addEventListener('click', function () {
            const input = document.getElementById('extraction');
            let value = parseInt(input.value) || 0;
            if (value < 100) input.value = value + 1;
        });

        document.getElementById('decreaseDose').addEventListener('click', function () {
            const input = document.getElementById('dose');
            let value = parseFloat(input.value) || 0.0;
            if (value > 0) input.value = (value - 0.1).toFixed(1);
        });

        document.getElementById('increaseDose').addEventListener('click', function () {
            const input = document.getElementById('dose');
            let value = parseFloat(input.value) || 0.0;
            input.value = (value + 0.1).toFixed(1);
        });

        document.getElementById('decreaseGrind').addEventListener('click', function () {
            const input = document.getElementById('grind_size');
            let value = parseInt(input.value) || 0;
            if (value > 0) input.value = value - 1;
        });

        document.getElementById('increaseGrind').addEventListener('click', function () {
            const input = document.getElementById('grind_size');
            let value = parseInt(input.value) || 0;
            input.value = value + 1;
        });
</script>
