<!DOCTYPE html>
<html lang="en">
<head>
    <title>Barrista Uber - by Davoud Taghawi-Nejad</title>
    <link href="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.css" rel="stylesheet">
    <script src="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; }
        .container { max-width: 800px; margin: auto; padding: 20px; }
        .controls { margin: 20px 0; }
        input { width: 100px; text-align: center; }
        canvas { max-width: 100%; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Barrista Uber - by Davoud Taghawi-Nejad</h1>
        <canvas id="lineChart" width="400" height="200"></canvas>
        <div class="controls">
            <h3>Adjust Values</h3>
            <label>Extraction (grams):</label>
            <button class="mdc-filled-button" id="decrease">-</button>
            <input type="number" id="extraction" min="0" max="100" value="{{extraction}}" step="1">
            <button class="mdc-filled-button" id="increase">+</button>
            <br><br>
            <button class="mdc-filled-button" onclick="updateValues()">Update</button>
            <button class="mdc-filled-button" onclick="makeCoffee()">Make Coffee</button>
        </div>
    </div>
    <script>
        let lineChart;
        let pollInterval;  // For polling data

        /**
 * Asynchronously fetches chart data from the server and updates the chart.
 * @async (this function runs asynchronously, allowing it to wait for the server response without blocking other parts of the page.)
 * @function loadData
 */
async function loadData() {
            try {
                const response = await fetch('/get_chart_data');
                if (!response.ok) throw new Error('Network response was not ok');
                const chartData = await response.json();
                lineChart.data.datasets[0].data = chartData;
                lineChart.update({ duration: 0 });  // Force instant update
            } catch (error) {
                console.error("Error loading data:", error);
                alert("Failed to load data. Please try again.");
            }
        }

        const ctx = document.getElementById('lineChart').getContext('2d');
        lineChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: Array.from({length: 6001}, (_, i) => i),  // Match the expected data length for 6000 points
                datasets: [{
                    label: 'Weight (grams)',
                    data: [],
                    borderColor: 'blue',
                    fill: false,
                    pointRadius: 0  // Hide points
                }]
            },
            options: {
                animation: {
                    duration: 0  // Explicitly disable all animations
                },
                transitions: false,  // Disable transitions
                scales: {
                    x: {
    title: { display: true, text: 'Time (seconds)' },
ticks: {
    callback: function(value, index) {
        if (index % 100 === 0 && index <= 6000) {  // Ensure up to 60 seconds with 100 points each
            return (index / 100);
        }
        return null;
    }
}
},
                    y: { title: { display: true, text: 'Weight (grams)' }, min: 0, max: 60}
                }
            }
        });

function startPolling() {
    if (pollInterval) {  // Check if an interval is already set
        clearInterval(pollInterval);  // Clear the existing interval to prevent duplicates
    }
    pollInterval = setInterval(loadData, 10);  // Set a new interval to poll data every 10ms (as per code, though comment suggests 1 second)
}

        window.onload = function() {
            loadData();
            startPolling();
        };

        /**
 * Asynchronously updates the preinfusion and extraction values on the server via a POST request.
 * @async (this function runs asynchronously, allowing it to wait for the server response without blocking other parts of the page.)
 * @function updateValues
 * @returns {Promise<void>} This indicates the function returns a promise that resolves when the operation is done, and it will display an alert to the user if the update succeeds or fails.
 */
async function updateValues() {
            const extraction = document.getElementById('extraction').value;
            const response = await fetch('/update', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ extraction })
            });
            if (response.ok) {
                alert('Values updated!');
                loadData();
            } else {
                alert('Update failed. Please try again.');
            }
        }

        /**
 * Sends a request to the server to start the coffee-making process.
 * @async (this function runs asynchronously, allowing it to wait for the server response without blocking other parts of the page.)
 * @function makeCoffee
 * @returns {Promise<void>} Shows an alert on success or failure.
 */
async function makeCoffee() {
            const extraction = document.getElementById('extraction').value;
            alert('Sending extraction value: ' + extraction);  // Debug alert to verify value
            const response = await fetch('/make_coffee', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ extraction })
            });
            if (response.ok) {
                alert('Coffee making started!');
            } else {
                alert('Coffee making failed. Please try again.');
            }
        }

// Add event listeners for buttons
document.getElementById('decrease').addEventListener('click', function() {
    const input = document.getElementById('extraction');
    let value = parseInt(input.value) || 0;
    if (value > 0) input.value = value - 1;
});

document.getElementById('increase').addEventListener('click', function() {
    const input = document.getElementById('extraction');
    let value = parseInt(input.value) || 0;
    if (value < 100) input.value = value + 1;
});
    </script>
</body>
</html>
