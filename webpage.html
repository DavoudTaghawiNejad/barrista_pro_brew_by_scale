<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/chartist.js/latest/chartist.min.css">
    <script src="https://cdn.jsdelivr.net/chartist.js/latest/chartist.min.js"></script>
    <title>Barrista Uber - by Davoud Taghawi-Nejad</title>
    <link href="https://unpkg.com/material-components-web@14.0.0/dist/material-components-web.min.css" rel="stylesheet">
    <script src="https://unpkg.com/material-components-web@14.0.0/dist/material-components-web.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; }
        .container { max-width: 800px; margin: auto; padding: 20px; }
        .controls { margin: 20px 0; }
        input { width: 100px; text-align: center; }
        canvas { max-width: 100%; }
        #chart-container {
            height: 600px;  /* Set to twice the assumed original height for better visibility */
        }
        /* Hide number input spin buttons (Chrome, Safari, Edge) */
        input[type=number]::-webkit-inner-spin-button,
        input[type=number]::-webkit-outer-spin-button {
        -webkit-appearance: none;
        margin: 0;
        }
        /* Hide number input spin buttons (Firefox) */
        input[type=number] {
        -moz-appearance: textfield;
        }
    </style>
    <style>
        .mdc-floating-label {
            text-align: left;  /* Align label to the left */
            position: absolute;  /* Ensure it's positioned absolutely if needed */
            left: 0;  /* Align to the left edge */
        }
        .mdc-notched-outline {
            display: flex;  /* Use flex to align contents */
            align-items: center;  /* Center vertically if needed */
        }
    </style>
</head>
<body>
    <div class="mdc-snackbar">
        <div class="mdc-snackbar__surface">
            <div class="mdc-snackbar__label" role="status" aria-live="polite"></div>
            <div class="mdc-snackbar__actions">
                <button type="button" class="mdc-button mdc-snackbar__action">
                    <div class="mdc-button__ripple"></div>
                    <span class="mdc-button__label">Dismiss</span>
                </button>
            </div>
        </div>
    </div>

    <div class="container">
        <h1>Barrista Uber - by Davoud Taghawi-Nejad</h1>
        <div id="chart-container"></div>
<div class="controls">
    <h3>Select or Create Coffee</h3>
    <label for="coffeeSelect">Coffee Profile:</label>
    <select id="coffeeSelect" class="mdc-select">
        <option value="">Select or Add Coffee</option>
        <!-- Options will be populated dynamically -->
    </select>
    <!-- Removed Load Coffees button -->
    <button class="mdc-button mdc-button--outlined" onclick="addNewCoffee()">Add New Coffee</button>
    <br><br>
    <h3>Adjust Values</h3>
    <label>Dose (grams):</label>
    <button class="mdc-button mdc-button--raised" id="decreaseDose">-</button>
    <label class="mdc-text-field mdc-text-field--outlined" style="width: 100px;">
        <input type="number" id="dose" class="mdc-text-field__input" step="0.1" min="0" style="width: 100px;">
        <span class="mdc-notched-outline">
          <span class="mdc-notched-outline__leading"></span>
          <span class="mdc-notched-outline__notch">
            <span class="mdc-floating-label"></span>
          </span>
          <span class="mdc-notched-outline__trailing"></span>
        </span>
      </label>
    <button class="mdc-button mdc-button--raised" id="increaseDose">+</button>
    <br><br>
    <label>Grind Size:</label>
    <button class="mdc-button mdc-button--raised" id="decreaseGrind">-</button>
    <label class="mdc-text-field mdc-text-field--outlined" style="width: 100px;">
        <input type="number" id="grind_size" class="mdc-text-field__input" step="1" min="0" style="width: 100px;">
        <span class="mdc-notched-outline">
          <span class="mdc-notched-outline__leading"></span>
          <span class="mdc-notched-outline__notch">
            <span class="mdc-floating-label"></span>
          </span>
          <span class="mdc-notched-outline__trailing"></span>
        </span>
      </label>
    <button class="mdc-button mdc-button--raised" id="increaseGrind">+</button>
    <br><br>
    <label>Extraction (grams):</label>
    <button class="mdc-button mdc-button--raised" id="decrease">-</button>
    <label class="mdc-text-field mdc-text-field--outlined" style="width: 100px;">
        <input type="number" id="extraction" class="mdc-text-field__input" min="0" min="200" style="width: 100px;" step="1">
        <span class="mdc-notched-outline">
          <span class="mdc-notched-outline__leading"></span>
          <span class="mdc-notched-outline__notch">
            <span class="mdc-floating-label"></span>
          </span>
          <span class="mdc-notched-outline__trailing"></span>
        </span>
      </label>
    <button class="mdc-button mdc-button--raised" id="increase">+</button>
    <br><br>
    <button class="mdc-button mdc-button--outlined" onclick="updateValues()">Remember Coffee</button>
    <button class="mdc-button mdc-button--raised" onclick="makeCoffee()">Make Coffee</button>
</div>
    </div>

<script>
let isMakingCoffee = false;
let pollInterval;
let snackbar;
const colors = ['red', 'green', 'blue', 'yellow', 'magenta', 'cyan', 'orange', 'purple', 'lime', 'navy', 'pink', 'brown'];
let colorIndex = -1;  // For cycling colors
let coffee_number = 0;

const chart = new Chartist.Line('#chart-container', {
        labels: [],
        series: [[]]
    }, {
        axisX: { type: Chartist.FixedScaleAxis, ticks: [0, 60], high: 60, low: 0 },
        axisY: { type: Chartist.FixedScaleAxis, ticks: [0, 60], high: 60, low: 0 }
    });

async function makeCoffee() {
    if (isMakingCoffee) {
        snackbar.labelText = 'Coffee is already being made.';
        snackbar.open();
        return;
    } else {
        snackbar.labelText = 'Making Coffee.';
        snackbar.open();
    }
    isMakingCoffee = true;
    coffee_number += 1
    const selectedCoffee = document.getElementById('coffeeSelect').value;
    const extraction = document.getElementById('extraction').value;


    colorIndex = (colorIndex + 1) % colors.length;  // Cycle color index
    try {
        const response = await fetch('/make_coffee', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name: selectedCoffee, extraction })
        });
        if (response.ok) {
            isMakingCoffee = false;
            clearInterval(pollInterval);
            snackbar.labelText = 'Coffee made successfully.';
            snackbar.open();
        } else {
            isMakingCoffee = false;
            clearInterval(pollInterval);
            snackbar.labelText = 'Coffee making failed.';
            snackbar.open();
        }
    } catch (error) {
        isMakingCoffee = false;
        clearInterval(pollInterval);
        snackbar.labelText = 'Error making coffee: ' + error.message;
        snackbar.open();
    }
    if (pollInterval) clearInterval(pollInterval);
    pollInterval = setInterval(async () => {
        try {
            const chartDataResponse = await fetch('/get_chart_data').catch(error => {
                console.error('Fetch error:', error);  // Catch fetch errors
                throw error;  // Re-throw to handle in outer catch
            });
            if (chartDataResponse.ok) {
                const responseData = await chartDataResponse.json().catch(error => {
                    console.error('JSON parse error:', error);  // Catch JSON parsing errors
                    throw error;
                });
                console.log('Fetched data:', responseData);
                if (responseData.is_makeing_coffee === false) {
                    clearInterval(pollInterval);
                    isMakingCoffee = false;
                    snackbar.labelText = 'Coffee made successfully.';
                    snackbar.open();
                } else if (responseData.data && responseData.data.length > 0) {
                    if (chart.data.series.length < coffee_number + 1) {
                        chart.data.series.push([{ meta: selectedCoffee + ' ' + (coffee_number), value: [] }]);
                    }
                    if (!chart.data.series[coffee_number].value) {
                        chart.data.series[coffee_number].value = [];}
                    chart.data.series[coffee_number].value = [...chart.data.series[coffee_number].value, ...responseData.data];
                    chart.update();
                    console.log('Chart updated with data');
                    const maxX = Math.max(...responseData.data.map(pair => pair[0] || 0), 60);
                    const maxY = Math.max(...responseData.data.map(pair => pair[1] || 0), 60);
                    if (maxX > 60 || maxY > 60) {
                        chart.options.axisX.high = maxX;
                        chart.options.axisY.high = maxY;
                        chart.update();
                    }
                } else {
                    console.log('No data received from API');
                }
            } else {
                console.error('API request failed:', chartDataResponse.status);
            }
        } catch (error) {
            console.error('Error in polling:', error);
        }
    }, 400);

}

async function updateValues() {
    const selectedCoffee = document.getElementById('coffeeSelect').value;
    const dose = document.getElementById('dose').value;
    const grind_size = document.getElementById('grind_size').value;
    const extraction = document.getElementById('extraction').value;

    if (selectedCoffee) {
        const data = { name: selectedCoffee };
        if (dose) data.dose = dose;
        if (grind_size) data.grind_size = grind_size;
        if (extraction) data.extraction = extraction;

        const response = await fetch('/update_coffee', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });
        if (response.ok) {
            snackbar.labelText = 'Coffee updated!';
            snackbar.open();
            // Removed loadData call
        } else {
            snackbar.labelText = 'Update failed. Please try again.';
            snackbar.open();
        }
    } else {
        snackbar.labelText = 'Please select a coffee first.';
        snackbar.open();
    }
}

async function loadCoffees() {
    const response = await fetch('/get_coffee_names');
    if (response.ok) {
        const data = await response.json();
        const select = document.getElementById('coffeeSelect');
        select.innerHTML = '<option value="">Select Coffee</option>';
        data.names.forEach(name => {
            const option = document.createElement('option');
            option.value = name;
            option.text = name;
            select.appendChild(option);
        });
    } else {
        snackbar.labelText = 'Failed to load coffees.';
        snackbar.open();
    }
}

async function addNewCoffee() {
    const name = prompt('Enter name for new coffee:');
    const dose = document.getElementById('dose').value;  // Add this line
    const grind_size = document.getElementById('grind_size').value;  // Add this line
    const extraction = document.getElementById('extraction').value;  // Add this line
    if (name && dose !== '' && grind_size !== '' && extraction !== '') {  // Check for all values
        const response = await fetch('/add_coffee', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name: name, dose: dose, grind_size: grind_size, extraction: extraction })
        });
        if (response.ok) {
            snackbar.labelText = 'New coffee added!';
            snackbar.open();
            loadCoffees();  // Reload coffees
        } else {
            snackbar.labelText = 'Failed to add coffee.';
            snackbar.open();
        }
    } else {
        snackbar.labelText = 'Please provide name, dose, grind_size, and extraction.';
        snackbar.open();
    }
}

window.onload = function () {
    loadCoffees().then(() => {
        // Fetch and set last brewed coffee after coffees are loaded
        async function fetchLastBrewed() {
            try {
                const response = await fetch('/get_last_brewed');
                if (response.ok) {
                    const data = await response.json();
                    const lastBrewed = data.last_brewed;
                    if (lastBrewed) {
                        document.getElementById('coffeeSelect').value = lastBrewed;
                        document.getElementById('coffeeSelect').dispatchEvent(new Event('change'));  // Trigger change to populate fields
                    }
                }
            } catch (error) {
                console.error("Error fetching last brewed coffee:", error);
            }
        }
        fetchLastBrewed();  // Call the function after loadCoffees, thanks to .then
    });
document.getElementById('coffeeSelect').addEventListener('change', async function() {
    const selectedCoffeeName = this.value;
    if (selectedCoffeeName) {
        const response = await fetch('/get_coffee?name=' + selectedCoffeeName);
        if (response.ok) {
            const data = await response.json();
            if (data.coffee) {  // Assuming the response is { 'coffee': { ... } }
                document.getElementById('dose').value = data.coffee.dose || '';
                document.getElementById('grind_size').value = data.coffee.grind_size || '';
                document.getElementById('extraction').value = data.coffee.extraction || '';
            } else {
                snackbar.labelText = 'Coffee details not found.';
                snackbar.open();
            }
        } else {
            snackbar.labelText = 'Failed to load coffee details.';
            snackbar.open();
        }
    } else {
        document.getElementById('dose').value = '';
        document.getElementById('grind_size').value = '';
        document.getElementById('extraction').value = '';
    }
});
    loadCoffees().then(() => {
        if (document.getElementById('coffeeSelect').options.length > 1) {
            document.getElementById('coffeeSelect').value = document.getElementById('coffeeSelect').options[document.getElementById('coffeeSelect').options.length - 1].value;
            document.getElementById('coffeeSelect').dispatchEvent(new Event('change'));
        }
    });
    // Initialize MDC buttons
    const buttons = document.querySelectorAll('.mdc-button');
    buttons.forEach(button => mdc.ripple.MDCRipple.attachTo(button));
    mdc.textField.MDCTextField.attachTo(document.querySelector('.mdc-text-field'));

    // Initialize snackbar once
    snackbar = mdc.snackbar.MDCSnackbar.attachTo(document.querySelector('.mdc-snackbar'));
};

        document.getElementById('decrease').addEventListener('click', function () {
            const input = document.getElementById('extraction');
            let value = parseInt(input.value) || 0;
            if (value > 0) input.value = value - 1;
        });

        document.getElementById('increase').addEventListener('click', function () {
            const input = document.getElementById('extraction');
            let value = parseInt(input.value) || 0;
            if (value < 100) input.value = value + 1;
        });

        document.getElementById('decreaseDose').addEventListener('click', function () {
            const input = document.getElementById('dose');
            let value = parseFloat(input.value) || 0.0;
            if (value > 0) input.value = (value - 0.1).toFixed(1);
        });

        document.getElementById('increaseDose').addEventListener('click', function () {
            const input = document.getElementById('dose');
            let value = parseFloat(input.value) || 0.0;
            input.value = (value + 0.1).toFixed(1);
        });

        document.getElementById('decreaseGrind').addEventListener('click', function () {
            const input = document.getElementById('grind_size');
            let value = parseInt(input.value) || 0;
            if (value > 0) input.value = value - 1;
        });

        document.getElementById('increaseGrind').addEventListener('click', function () {
            const input = document.getElementById('grind_size');
            let value = parseInt(input.value) || 0;
            input.value = value + 1;
        });
</script>
